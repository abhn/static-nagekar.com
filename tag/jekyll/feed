<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>jekyll &#8211; Abhishek Nagekar</title>
	<atom:link href="https://nagekar.com/tag/jekyll/feed" rel="self" type="application/rss+xml" />
	<link>https://nagekar.com</link>
	<description>hobbyist {x}</description>
	<lastBuildDate>Mon, 16 Mar 2020 23:00:00 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://nagekar.com/wp-content/uploads/2020/12/cropped-cropped-cropped-favicon-32x32.png</url>
	<title>jekyll &#8211; Abhishek Nagekar</title>
	<link>https://nagekar.com</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Elementary Theme For Jekyll</title>
		<link>https://nagekar.com/2020/03/elementary-theme.html</link>
		
		<dc:creator><![CDATA[Abhishek Nagekar]]></dc:creator>
		<pubDate>Mon, 16 Mar 2020 23:00:00 +0000</pubDate>
				<category><![CDATA[jekyll]]></category>
		<guid isPermaLink="false">http://wp.nagekar.com/2020/03/16/elementary-theme/</guid>

					<description><![CDATA[It is hardly ever the case that I work on a single side project for years, a sentiment that my fellow software developers might share with me. This blog that you&#8217;re reading this article on is one such rare project. And although there have been crests and troughs in terms of my activity here, it [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>
  It is hardly ever the case that I work on a single side project for years, a sentiment that my fellow software developers might share with me. This blog that you&#8217;re reading this article on is one such rare project. And although there have been crests and troughs in terms of my activity here, it has been fairly consistent, especially considering my reputation of abandoning projects.
</p>
<p>
  Anyway. Where I was going with all that blabber was that this template that you&#8217;re reading this on is already two years old now, and I recently <a href="https://github.com/abhn/Elementary">rolled out an update</a> that I was pretty proud of. In this little post, I&#8217;d like to outline in brief how I reached the current version of this template and why I&#8217;m super happy with the outcome.
</p>
<h3>Backstory</h3>
<p>
  I created the template by simply removing as many unnecessary parts of my then current template as possible and making it a simple, one request only template. It was essentially a blank HTML page with few lines of CSS, no JavaScript, default browser font and styles. Of course, it was blazingly fast but also quite ugly. I went to the extreme end of the spectrum as my starting point.
</p>
<p>
  Slowly, I added stuff to it, on a strictly per-requirement basis. More CSS, some JavaScript, introduced SCSS to make the CSS maintainable, made the JavaScript optional as not everyone needs a dark mode and so on. I made the project installable via git submodule so that it is easy to customize it and at the same time pull updates from upstream.
</p>
<h3>Current status</h3>
<p>
  It feels good to not trigger advertisement and tracker blocking tools like uBlock Origin. And by not loading hundreds of kilobytes of minified code that contains trackers, suboptimized routines and who knows what, I&#8217;m also being fair to my visitors who, when you think about it, trust you as the web developer by loading and executing your code on their machines.
</p>
<p>
  On a more objective side of things, here are a couple of features (copied over from the project&#8217;s github readme) I&#8217;m super happy to announce:
</p>
<ul>
<li>Lightweight, <10KB CSS, <3KB (optional) JavaScript + 15KB Open Sans font file + your content. That's less than 40KB transferred for most pages</li>
<li>Highly accessible with semantic HTML</li>
<li>Structured data (schema.org) pre-added for blog posts</li>
<li>Dark mode (requires JavaScript for toggling class and saving user preference in cookies)</li>
<li>Reading progress slider on top (requires JavaScript)</li>
<li>JavaScript is optional (turn it off in _config.yml)</li>
<li>No request made to any third party</li>
<li>Installable as a git submodule</li>
</ul>
<p>
  Try the project here: <a href="https://elementary-jekyll.github.io/">https://elementary-jekyll.github.io/</a>. Below is a picture collage of interesting observations about the theme.
</p>
<figure>
  <a href="https://www.nagekar.com/wp-content/uploads/2020/12/perf-2.jpg"><br />
    <img decoding="async" src="https://www.nagekar.com/wp-content/uploads/2020/12/perf-2.jpg" alt="Picture showing 100 score on Google Page Speed, <1 second median load time, 100% cached on Cloudflare and a screenshot of the template running on Kindle"/><br />
  </a><figcaption>Picture showing 100 score on Google Page Speed, <1 second median load time, 100% cached on Cloudflare and a screenshot of the template running on Kindle. Mobile users can click on the image.</figcaption></figure>
<p>
  Here&#8217;s what the dark mode toggle looks like.
</p>
<figure>
  <img decoding="async" src="https://www.nagekar.com/wp-content/uploads/2020/12/dark-mode.gif" alt="Dark mode demonstration"/><br />
</figure>
<p>
  And this is the scroll progress indicator
</p>
<figure>
  <img decoding="async" src="https://www.nagekar.com/wp-content/uploads/2020/12/scroll-progress.gif" alt="Reading time indicator" /><br />
</figure>
<h3>Todo and future</h3>
<p>
  I&#8217;m probably not going to give up on this template just yet. But I really want to move away from Jekyll now. No, I don&#8217;t dislike it. It is probably perfect if you just want to focus on writing as a person who doesn&#8217;t mind using text editors and the terminal. I just want to be able to dig into the source code of the build tool, the configuration files, write a plugin myself, be more comfortable with the whole ecosystem in general. To do that, it is important that I move to a tool that&#8217;s written in a language I know, or want to learn. Jekyll, and hence Ruby, just isn&#8217;t either of those.
</p>
<p>
  If you&#8217;re thinking of starting a blog, or moving to a new template and see this one a good fit for your taste, do give it a shot. In case you actually end up using it, please write to me. Of course, it is open source and GPLv3 licensed. In the future, if I manage to move my blog elsewhere, I&#8217;ll port this template to the new system.
</p>
<p>
  I remember wanting to have a simple static site generator after having struggled with tools like WordPress and Blogspot for this blog. I&#8217;ve reached a point where I feel like I need some of that complexity back. Guess I&#8217;ve reached the other side of the sine curve!
</p>
<p>
  Thank you for reading.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Search On Jekyll Blogs</title>
		<link>https://nagekar.com/2019/05/search-on-jekyll-blog.html</link>
		
		<dc:creator><![CDATA[Abhishek Nagekar]]></dc:creator>
		<pubDate>Sun, 12 May 2019 22:00:00 +0000</pubDate>
				<category><![CDATA[jekyll]]></category>
		<category><![CDATA[web]]></category>
		<guid isPermaLink="false">http://wp.nagekar.com/2019/05/12/search-on-jekyll-blog/</guid>

					<description><![CDATA[Static site generators are great. No fuss, pure purpose. I use Jekyll because that&#8217;s what Github supports the best. But these days, with services like Netlify, you have many options. This site aggregates the top ones, so give it a look if you&#8217;re planning on setting up one for yourself. staticgen.com is a nice website [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>
  Static site generators are great. No fuss, pure purpose. I use Jekyll because that&#8217;s what Github supports the best. But these days, with services like Netlify, you have many options. <a href="https://www.staticgen.com/">This site</a> aggregates the top ones, so give it a look if you&#8217;re planning on setting up one for yourself.
</p>
<figure>
  <img decoding="async" src="https://www.nagekar.com/wp-content/uploads/2020/12/staticgen.com_.png"/><figcaption>staticgen.com is a nice website to find a static site generator right for you</figcaption></figure>
<p>
  One thing that&#8217;s tricky with static site generators is search functionality. Since there&#8217;s no backend, whatever you plan on searching has to be generated the same way other content is. Often, that means iterating over all posts and creating a json file which you can fetch in the frontend and do offline search.
</p>
<p>
  While that works, it doesn&#8217;t give you full content search (if you include content in that json blob, it will grow in size and get slower with each new post). But full content search is exactly what you need at times. I needed content search, and I spent sometime researching the options that exist. Below, I&#8217;ll list a couple of them, not necessarily only the ones that offer full content search but each suited to some specific use case.
</p>
<h3>Netlify Functions</h3>
<p>
  Netlify has managed cloud functions thingy <i>(serverless)</i> and it works on top of AWS Lambda. It is very simple to write a function with netlify, and when you push your code, the functions are deployed as well. It comes with a free tier which runs on a 128mb instance. Pretty low, and would time out in 10 seconds if you give it a lot of work.
</p>
<p>
  Netlify picks functions from a directory and pushes them to aws internally. Now, we need our json file to be present in Netlify lambdas directory before the push happens. We can make use of a simple node module <a href="https://github.com/jxson/front-matter">Front Matter</a> that would take our <code>_posts</code> directory and return a nice json with frontmatter and body parsed. Then we take this json and write it to a file which we can then import from our lambda function.
</p>
<p><script src="https://gist.github.com/abhn/739b0e4fb4555c8971e04f00ed75c247.js"></script></p>
<p>
  Now, for the search function, we can use something like <a href="https://github.com/nextapps-de/flexsearch">FlexSearch</a> that does offline searching. Just that we&#8217;ll use it in the lambda.
</p>
<p><script src="https://gist.github.com/abhn/f21ca434754a364451060fe16dca0efc.js"></script></p>
<p>
  And you should update your build command in netlify&#8217;s <code>netlify.toml</code> file (or web interface) to run the node script before the jekyll build step.
</p>
<pre>
  $ npm run create-json && jekyll build
</pre>
<p>
  Keep in mind that the free tier is very low-duty. Try to strip down content by filtering <a href="https://en.wikipedia.org/wiki/Stop_words">stopwords</a> and doing other optimizations.
</p>
<p>
  On the frontend, you make a GET request with query parameter <i>q</i> to this endpoint like you would with a regular backend search.
</p>
<h3>Algolia (or any search as a service)</h3>
<p>
  I&#8217;d start with stating why Algolia didn&#8217;t fit very well for my use case. Their record (think each individual post text plus metadata) size limit is 10kb, so if your content is frequently more than that, and you want it to be searchable, Algolia might not be the best for you. But if you don&#8217;t need full content search, or if you write little posts that are usually less than 10kb, it might be a good option to look into.
</p>
<p>
  Essentially, you create a searchable index on Algolia (simply upload a json file or use their <code>jekyll-algolia</code> gem), and use their client side libraries to query this index. They have a nice and simple web interface to do it manually or just use a script to automate it via their APIs.
</p>
<p>
  Like mentioned before, you can implement a two step deploy process to Algolia that removes stopwords and duplicate words from the text before pushing the index. That way you can still fit the record in 10kb.
</p>
<h3>AWS Lambda</h3>
<p>
  Netlify search uses AWS Lambda internally, but netlify only offers a couple of tiers ($0, $25 and a custom plan for $500 paying customers). On the other hand, AWS has a wide variety of lambda instance sizes and charge per usage which makes it super cheap.
</p>
<p>
  What you lose in this case (compared to Netlify functions) is that you have to set up the CI pipeline yourself from scratch. So no automated pushing of the functions along with your static site. If you have a lot of searches, or heavy search queries, AWS Lambda is the way to go. For very simple and light weight use cases, Netlify isn&#8217;t a bad choice. Note that Netlify also deploys to AWS, so your function will work on either service with little to no modifications.
</p>
<h3>ElasticSearch</h3>
<p>
  This is a complex solution when compared to the others on this list. Essentially you create a simple app on, say Heroku with a simple GET and POST interface. You can pair this app with a free <a href="https://app.bonsai.io/signup">Bonsai ElasticSearch</a> instance. The POST will push data to this instance and GET will fetch search results.
</p>
<p>
  The middleware Heroku app is to simple prevent our Bonsai credentials from getting into the wild. I didn&#8217;t think this was a good solution for simple use cases because of the maintenance factor. The reason we use Jekyll (or any static site generator) is to keep things simple, and this search solution is hard to sell to people like us.
</p>
<h3>In closing</h3>
<p>
  As I found out, there are many ways of implementing a good search feature on a Jekyll (or any statically generated site). I&#8217;ve left out details of the implementation as I couldn&#8217;t find time to do so but what I learned was that just knowing that these options exist helps a lot. So the next time I&#8217;m thinking, &#8220;hmm, I&#8217;d like to have a search here, but not sure how to handle the logistics that come with it&#8221;, I&#8217;d already have a few options!
</p>
<p>
  Thank you for reading.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
