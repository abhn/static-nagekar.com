{"id":1070,"date":"2018-07-08T22:00:00","date_gmt":"2018-07-08T22:00:00","guid":{"rendered":"http:\/\/wp.nagekar.com\/2018\/07\/08\/eli5-how-https-works\/"},"modified":"2018-07-08T22:00:00","modified_gmt":"2018-07-08T22:00:00","slug":"eli5-how-https-works","status":"publish","type":"post","link":"https:\/\/nagekar.com\/2018\/07\/eli5-how-https-works.html","title":{"rendered":"ELI5 &#8211; How HTTPS Works"},"content":{"rendered":"<style>\n  img {\n    border: 2px black solid;\n  }\n<\/style>\n<p>\n\tLet&#8217;s start with some basics. Just like when you want to talk to another person, you talk in a language that both of you understand, every system that wants to talk to another system needs to talk in a commonly understood language. Technically, we call it a protocol. <a href=\"https:\/\/en.wikipedia.org\/wiki\/HTTPS\">HTTPS<\/a> is a protocol, and so is English. Every protocol is designed with some goals in mind. For real-world languages, the goals are simple. They are usually communication, literature and so on. With computer protocols, the goals have to be more stringent. Usually, different computer protocols have very different purposes. For example, File Transfer Protocol (FTP) was (and still is) widely used for transferring files, Secure Shell (SSH) is used for remote administration and so on.\n<\/p>\n<p>\n\tNote that we&#8217;re only talking about application layer protocols in the <a href=\"https:\/\/en.wikipedia.org\/wiki\/Internet_Protocol\">Internet Protocol Suite<\/a>. Once the appropriate protocol in the application layer creates a packet for transmission, this is encapsulated in many coverings, one by one, by all the layers beneath it. Each layer attaches its own header to the message, which then becomes the message for the next layer to attach its header on. A reverse of this process happens on the recipient&#8217;s end. It is easier to imagine this process as peeling of layers of an onion.\n<\/p>\n<p>\n\tSo having that set, we&#8217;ll start out discussion about HTTPS. HTTPS, or HTTP Secure, is an application layer protocol that provides HTTP traffic encryption using TLS (Transport Layer Security) or its predecessor, SSL. The underlying application doesn&#8217;t have to worry about HTTP or HTTPS, and once the initial handshake is done, for the most part, it is just an HTTP connection, one that is over a secure tunnel. I&#8217;ve been a frontend engineer and I&#8217;ve never written any specific HTTPS code, ever. That&#8217;s the magic of TLS.\n<\/p>\n<h3>What&#8217;s TLS?<\/h3>\n<p>\n\tSo HTTP that is encrypted using TLS is HTTPS. Got it. But what about TLS then? For starters, TLS is a hybrid cryptosystem. It uses multiple <a href=\"https:\/\/en.wikipedia.org\/wiki\/Cryptographic_primitive\">cryptographic primitives<\/a> underneath its hood to achieve its goals.\n<\/p>\n<p>\n\t<b>Aside on cryptographic primitives:<\/b> Cryptographic primitives, like symmetric encryption, block ciphers and so on are designed by experts who know what they&#8217;re doing. The role of protocol implementers is to take these primitives and combine them in useful ways to accomplish certain goals.\n<\/p>\n<p>\n\tTLS uses symmetric key encryption, asymmetric key encryption, and (sometimes) <a href=\"\/2018\/07\/eli5-message-authentication-code.html\">message authentication code<\/a> to establish an encrypted bidirectional data tunnel and transfer encrypted bits. We&#8217;ll try to explore how each primitive is used to attain some goal in a bit. With these primitives, particularly with <a href=\"https:\/\/en.wikipedia.org\/wiki\/Public_key_infrastructure\">public key infrastructure (PKI)<\/a>, TLS establishes the identity of one or both the parties involved in a communication (your browser and the web server in most cases).  Then, a key is derived at both the ends using another primitive called <a href=\"https:\/\/security.stackexchange.com\/questions\/45963\/diffie-hellman-key-exchange-in-plain-english\">Diffie Hellman<\/a> or <a href=\"https:\/\/en.wikipedia.org\/wiki\/RSA_(cryptosystem)\">RSA<\/a> which are asymmetric key crypto algorithms. Once the key is derived, this key can be used as the session key to be used in symmetric key algorithms like AES. If an <a href=\"https:\/\/www.nagekar.com\/2018\/07\/eli5-message-authentication-code.html\">authenticated encryption<\/a> mode is not used (such as GCM), then a MAC algorithm might also be needed (such as HMAC). Also, a hashing algorithm (such as <a href=\"https:\/\/en.wikipedia.org\/wiki\/SHA-2\">SHA256<\/a>) is used to authenticate the initial handshake (and as a PRF if HMAC is used). Let&#8217;s try to follow a typical HTTPS handshake and see what we learn during it.\n<\/p>\n<h3>In the beginning&#8230;<\/h3>\n<p>\n\tIn the beginning, there was no connection. You open your browser and type in <b>nagekar.com<\/b>. The following things will happen in that order, more or less.<\/p>\n<ul>\n<li>Your browser send a <b>DNS resolution request<\/b> for nagekar.com.<\/li>\n<p>  <img decoding=\"async\" src=\"https:\/\/www.nagekar.com\/wp-content\/uploads\/2020\/12\/dns_request.png\"\/><\/p>\n<li>Your router (or any DNS resolution service) will provide you with the <b>IP address<\/b> of the host<\/li>\n<p>  <img decoding=\"async\" src=\"https:\/\/www.nagekar.com\/wp-content\/uploads\/2020\/12\/dns_response.png\"\/><\/p>\n<li>Now the <b><a href=\"https:\/\/en.wikipedia.org\/wiki\/Handshaking#TCP_three-way_handshake\">three way TCP handshake<\/a><\/b> that we studied in our networking classes happen (SYN -> SYN\/ACK -> ACK).<\/li>\n<p>  <img decoding=\"async\" src=\"https:\/\/www.nagekar.com\/wp-content\/uploads\/2020\/12\/three_way.png\"\/><\/p>\n<li>After establishing a TCP connection, your browser makes a request to <b>104.28.11.84<\/b> for host <b>nagekar.com<\/b>. The server responds with a <b>301 Moved Permanently<\/b> as my website is only accessible over HTTPS and with the WWW subdomain.<\/li>\n<p>  <img decoding=\"async\" src=\"https:\/\/www.nagekar.com\/wp-content\/uploads\/2020\/12\/redirect.png\"\/><\/p>\n<li>Now starts the TLS handshake. First client sends a <b>client hello<\/b>. It contains the following important pieces of data:\n<ul>\n<li>A <b>random 28 byte string<\/b> (later used for establishing session key).<\/li>\n<li><b>Session ID<\/b> (used for resuming a previously established session and avoiding the entire handshake altogether, 0 here because no previous sessions found).<\/li>\n<li><b>Cipher suites<\/b> supported by the client in order of preference.<\/li>\n<li><b>Server name<\/b> (this enables the server to identify which site&#8217;s certificate to offer to the client in case multiple websites are hosted from a single IP address, as in the case with most small\/medium websites).<\/li>\n<\/ul>\n<\/li>\n<p>  <img decoding=\"async\" src=\"https:\/\/www.nagekar.com\/wp-content\/uploads\/2020\/12\/client_hello.png\"\/><\/p>\n<li>Then server sends a <b>server hello<\/b> which has the following important pieces of data:\n<ul>\n<li>Another <b>random 28 byte string<\/b> (later used for establishing session key)<\/li>\n<li>Cipher suite selected by server (in our case, the server selected <b>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256<\/b> which was our most preferred cipher suite)<\/li>\n<\/ul>\n<\/li>\n<p>  <img decoding=\"async\" src=\"https:\/\/www.nagekar.com\/wp-content\/uploads\/2020\/12\/server_hello.png\"\/><\/p>\n<li>At this point, both client and server have the necessary information to establish an encrypted tunnel, but one important detail is missing. No party has verified the identity of the other party (and if not done, it really defeats the purpose of whatever came before this since an active man-in-the-middle adversary could easily break this scheme). This is done in the certificate message. In most cases, only the client will verify the identity of the server. Here&#8217;s how it looks like:<\/li>\n<p>  <img decoding=\"async\" src=\"https:\/\/www.nagekar.com\/wp-content\/uploads\/2020\/12\/server_hello_done.png\"\/><\/p>\n<li>And this is exactly what you see when you click on the green padlock icon in your address bar and try to see more information about the certificate offered by the website.<\/li>\n<p>  <img decoding=\"async\" src=\"https:\/\/www.nagekar.com\/wp-content\/uploads\/2020\/12\/server_certificate.png\"\/><\/p>\n<li>At this point, the <b>server hello<\/b> is done. It is indicated in the message that the server won&#8217;t be asking the client for a certificate.<\/li>\n<li>The server sends one half of the Diffie Hellman key in a separate <b>Server Key Exchange<\/b> message. Following this, the client sends other half of the Diffie Hellman key exchange. After that, the client sends a <b>Change Cipher Spec<\/b> message which means any subsequent message from the client will be encrypted with the schemes just negotiated. Lastly, the client sends the first encrypted message, an encrypted handshake.<\/li>\n<p>  <img decoding=\"async\" src=\"https:\/\/www.nagekar.com\/wp-content\/uploads\/2020\/12\/client_key_change.png\"\/><\/p>\n<li>On similar lines, server issues the client a <b>Session Ticket<\/b> which the client can then use to resume connections and not go through the entire Diffie Hellman procedure again (although it is valid only for 18 hours in our case). The server sends a <b>Change Cipher Spec<\/b> message, indicating that no more plaintext messages will be sent by the server. Lastly, the server sends its first encrypted message, an encrypted handshake, just like the client.<\/li>\n<p>  <img decoding=\"async\" src=\"https:\/\/www.nagekar.com\/wp-content\/uploads\/2020\/12\/server_key_change.png\"\/><\/p>\n<li>That&#8217;s it. We have established a secure connection to a computer on the other side of the planet and verified its identity. Magic!<\/li>\n<\/ul>\n<h3>Crypto Primitives<\/h3>\n<p>\n  Let&#8217;s discuss what goal of cryptography is achieved by what part of this entire handshake. Remember the cipher suite that the server choose? It was <b>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256<\/b>.\n<\/p>\n<p>\n  <b>ECDHE<\/b>: <a href=\"https:\/\/www.ecdhe.com\/\">ephemeral Elliptical Curve Diffie Hellman<\/a>, as we saw, is used to establish a shared secret session key from the random values our client and the server exchanged (over an insecure channel). It is a key exchange crypto.\n<\/p>\n<p>\n  <b>ECDSA<\/b>: <a href=\"https:\/\/en.wikipedia.org\/wiki\/Elliptic_Curve_Digital_Signature_Algorithm\">Elliptical Curve Digital Signature Algorithm<\/a> is used to verify the public key supplied by the server, in our case nagekar.com, issued for Cloudflare by COMODO.\n<\/p>\n<p>\n  <b>AES 128 with GCM<\/b>: <a href=\"https:\/\/en.wikipedia.org\/wiki\/Advanced_Encryption_Standard\">AES<\/a> is a block cipher. Being a symmetric key encryption algorithm, it is much faster than the asymmetric key ones, and hence used for encryption of all the data after the initial handshake is done. 128 is the size of the key in bits, which is sufficiently secure. GCM stands for <a href=\"https:\/\/en.wikipedia.org\/wiki\/Galois\/Counter_Mode\">Galois\/Counter Mode<\/a>, which is an encryption mode used with AES to provide authentication and integrity along with the <i>regular<\/i> confidentiality.\n<\/p>\n<p>\n  <b><a href=\"https:\/\/en.wikipedia.org\/wiki\/SHA-2\">SHA256<\/a><\/b>: Since we&#8217;re using AES with GCM, we won&#8217;t be using this hash function for message authentication. However, since TLS 1.2, SHA256 is used as a PRF. It will also be used to verify that all content exchanged during the handshake were not tampered with.\n<\/p>\n<h3>Security Considerations<\/h3>\n<p>\n  <b>About trust:<\/b> As you might have noticed, all the above steps were essentially so that two random computers can come up with a shared secret session key. The other part to this is Certificate Authorities. Why did we trust the certificate that the server sent us? Because it was signed by someone, whom we trusted. At the end of it all, you still have to implicitly trust someone to verify the identity. In this case, we&#8217;re trusting COMODO to have only signed one certificate for the domain in question.<br \/>\n  <img decoding=\"async\" src=\"https:\/\/www.nagekar.com\/wp-content\/uploads\/2020\/12\/website_identity.png\"\/>\n<\/p>\n<p>\n  <b>About browser and updates:<\/b> If you see the version of TLS that we used, it is 1.2 which is not the latest. The cipher suite is also not the best we could&#8217;ve got. Why did that happen? Simple, because we were using an outdated browser which didn&#8217;t support the strongest cipher suites and the latest version of TLS. Since that was a test machine, it doesn&#8217;t matter a lot. On any up to date browser, this is what you should see.<br \/>\n  <img decoding=\"async\" src=\"https:\/\/www.nagekar.com\/wp-content\/uploads\/2020\/12\/updated_browser.png\"\/>\n<\/p>\n<p>\n  <b>About cryptographic primitives:<\/b> We saw some of the most understood crypto primitives being used in the handshake. This is a pattern you&#8217;ll see often while reading about cryptology. It is a sin to implement your own crypto, especially the primitives. Use a library that implements these primitives, or better yet, the entire cryptosystem.\n<\/p>\n<p>\n  <b>About mathematics:<\/b> The reason that we think the above scheme is secure, that no data is leaked even though key was generated using the information sent in clear, is because the basis of some of these cryptographic primitives are hard problems in mathematics. For example, since mathematicians believe that discrete logarithms are easy to verify but are hard to calculate the other way, we say that Diffie Hellman (which makes use of discrete logarithms) is secure. Similarly with RSA, mathematicians believe that factoring large prime numbers is a hard problem, hence RSA is considered secure as long as the numbers are large enough. Of course, not always is a mathematical proof available. For example, AES is considered secure, but there&#8217;s not proof that it is secure. We <i>think<\/i> it must be secure because the brightest minds in cryptology have spent thousands of man hours trying to break the encryption algorithm but they haven&#8217;t succeeded (yet?).\n<\/p>\n<h3>In Closing<\/h3>\n<p>\n  As you can guess, a lot of important details are skipped in this article. There are two reasons for that. 1. I lack the necessary knowledge to simplify the deeper parts and 2. It would be boring to read if the post felt like a spec. If you wish to read more, refer to the list of references below this section.\n<\/p>\n<h3>References<\/h3>\n<ul>\n<li><a href=\"https:\/\/en.wikipedia.org\/wiki\/HTTPS\">https:\/\/en.wikipedia.org\/wiki\/HTTPS<\/a>\n<li><a href=\"https:\/\/blog.hartleybrody.com\/https-certificates\/\">https:\/\/blog.hartleybrody.com\/https-certificates\/<\/a>\n<li><a href=\"https:\/\/security.stackexchange.com\/questions\/45963\/diffie-hellman-key-exchange-in-plain-english\">https:\/\/security.stackexchange.com\/questions\/45963\/diffie-hellman-key-exchange-in-plain-english<\/a>\n<li><a href=\"https:\/\/en.wikipedia.org\/wiki\/Public_key_infrastructure\">https:\/\/en.wikipedia.org\/wiki\/Public_key_infrastructure<\/a>\n<li><a href=\"https:\/\/www.moserware.com\/2009\/06\/first-few-milliseconds-of-https.html\">https:\/\/www.moserware.com\/2009\/06\/first-few-milliseconds-of-https.html<\/a>\n<li><a href=\"https:\/\/tools.ietf.org\/html\/rfc5246\">https:\/\/tools.ietf.org\/html\/rfc5246<\/a>\n<li><a href=\"https:\/\/albertx.mx\/https-handshake\/\">https:\/\/albertx.mx\/https-handshake\/<\/a>\n<li><a href=\"https:\/\/security.stackexchange.com\/questions\/20803\/how-does-ssl-tls-work\/20847\">https:\/\/security.stackexchange.com\/questions\/20803\/how-does-ssl-tls-work\/20847<\/a>\n<li><a href=\"https:\/\/blog.filippo.io\/we-need-to-talk-about-session-tickets\/\">https:\/\/blog.filippo.io\/we-need-to-talk-about-session-tickets\/<\/a>\n<li><a href=\"https:\/\/security.stackexchange.com\/questions\/8343\/what-key-exchange-mechanism-should-be-used-in-tls\">https:\/\/security.stackexchange.com\/questions\/8343\/what-key-exchange-mechanism-should-be-used-in-tls<\/a>\n<\/ul>\n<p>Thank you for reading!<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Let&#8217;s start with some basics. Just like when you want to talk to another person, you talk in a language that both of you understand, every system that wants to talk to another system needs to talk in a commonly understood language. Technically, we call it a protocol. HTTPS is a protocol, and so is [&hellip;]<\/p>\n","protected":false},"author":2,"featured_media":473,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[],"tags":[7,6],"class_list":["post-1070","post","type-post","status-publish","format-standard","has-post-thumbnail","hentry","tag-cryptography","tag-eli5"],"_links":{"self":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/posts\/1070","targetHints":{"allow":["GET"]}}],"collection":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/comments?post=1070"}],"version-history":[{"count":0,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/posts\/1070\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/media\/473"}],"wp:attachment":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/media?parent=1070"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/categories?post=1070"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/tags?post=1070"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}