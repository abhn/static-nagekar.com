{"id":1121,"date":"2016-04-14T22:00:00","date_gmt":"2016-04-14T22:00:00","guid":{"rendered":"http:\/\/wp.nagekar.com\/2016\/04\/14\/websockets\/"},"modified":"2016-04-14T22:00:00","modified_gmt":"2016-04-14T22:00:00","slug":"websockets","status":"publish","type":"post","link":"https:\/\/nagekar.com\/2016\/04\/websockets.html","title":{"rendered":"WebSockets"},"content":{"rendered":"<p>\n\tIf you&#8217;re like me, then you must have gone nuts on hearing about <a href=\"https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/WebSockets_API\">WebSockets<\/a> for the first time. We now have a totally independent protocol that will not terminate connection after a request-response cycle, which means all hacks to keep a persistent connection from the browser (long polling, I&#8217;m looking at you) would now be part of the history. Welcome to the world of WebSockets.\n<\/p>\n<p>\n\tLet&#8217;s start with the Wikipedian and Mozillian definition of WebSockets, to get some initial traction.\n<\/p>\n<h6>Wikipedia says that..<\/h6>\n<blockquote><p>\n\tWebSocket is a protocol providing full-duplex communication channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as RFC 6455 in 2011, and the WebSocket API in Web IDL is being standardized by the W3C.\n<\/p><\/blockquote>\n<h6>Mozilla Developer Network says that..<\/h6>\n<blockquote><p>\n\tWebSockets is an advanced technology that makes it possible to open an interactive communication session between the user&#8217;s browser and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply.\n<\/p><\/blockquote>\n<p>\n\tTo begin with, let us all make sure we have websocket support by clicking <button id=\"hasBtn\" onclick=\"hasSocket();\">here<\/button>. Assuming you do, let&#8217;s begin. Web browsers provide us with the <code>WebSocket<\/code> class. To create a websocket, we simply need to <\/p>\n<pre>let ws = new WebSocket('ws:\/\/server.com\/endpoint');<\/pre>\n<p>This gives us a <i>websocket<\/i> object which supports methods like send() and close() and event listeners like onmessage and onerror.\n<\/p>\n<p>\n\tCreating a nodejs instance running a websocket server is easy with modules. I did try to do it natively, but it went too tedious. Finally I settled for <code>ws<\/code> module from npm. The server side code looks trival.\n<\/p>\n<p><script src=\"https:\/\/gist.github.com\/abhn\/d94830c3901b48ebdeb8375b37d0ee60.js\"><\/script><\/p>\n<p>\n\tOn the browser, things are even simpler.\n<\/p>\n<figure class=\"highlight\">\n<pre><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"c1\">\/\/ call the object constructor<\/span>\n<span class=\"kd\">var<\/span> <span class=\"nx\">ws<\/span> <span class=\"o\">=<\/span> <span class=\"k\">new<\/span> <span class=\"nx\">WebSocket<\/span><span class=\"p\">(<\/span><span class=\"dl\">'<\/span><span class=\"s1\">ws:\/\/nagekar-ws.herokuapp.com\/<\/span><span class=\"dl\">'<\/span><span class=\"p\"&gt;);<\/span>\n<span class=\"c1\">\/\/ attach a message listener<\/span>\n<span class=\"nx\">ws<\/span><span class=\"p\">.<\/span><span class=\"nx\">onmessage<\/span> <span class=\"o\">=<\/span> <span class=\"kd\">function<\/span><span class=\"p\">(<\/span><span class=\"nx\">msg<\/span><span class=\"p\">)<\/span> <span class=\"p\">{<\/span>\n\t<span class=\"nx\">console<\/span><span class=\"p\">.<\/span><span class=\"nx\">log<\/span><span class=\"p\">(<\/span><span class=\"nx\">msg<\/span><span class=\"p\"&gt;);<\/span>\n<span class=\"p\">}<\/span>\n<span class=\"c1\">\/\/ send some message<\/span>\n<span class=\"nx\">ws<\/span><span class=\"p\">.<\/span><span class=\"nx\">send<\/span><span class=\"p\">(<\/span><span class=\"dl\">'<\/span><span class=\"s1\">hello server!<\/span><span class=\"dl\">'<\/span><span class=\"p\"&gt;);<\/span><\/code><\/pre>\n<\/figure>\n<p>\n\tOnce we call the constructor, an HTTP GET request is generated to initiate the transaction. You&#8217;ll find that these headers are sent by your browser.\n<\/p>\n<pre>\n\nGET \/ HTTP\/1.1\nHost: nagekar-ws.herokuapp.com\nConnection:Upgrade\nPragma:no-cache\nSec-WebSocket-Extensions:permessage-deflate; client_max_window_bits\nSec-WebSocket-Key:ut0NjBQxxBnmtUStHfMUDw==\nSec-WebSocket-Version:13\nUpgrade:websocket\nUser-Agent:Mozilla\/5.0 (X11; Linux x86_64) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/49.0.2623.108 Safari\/537.36\n<\/pre>\n<p>\n\tThe ones to notice are the URL, which begins with ws:\/\/ protocol. <a href=\"https:\/\/stackoverflow.com\/questions\/23674199\/why-is-there-no-same-origin-policy-for-websockets-why-can-i-connect-to-ws-loc#comment36372038_23674863\">Cross domain requests<\/a> are allowed. This initial step requires the use of HTTP(S) or web, hence the name &#8216;web&#8217; sockets. The <i>&#8216;Connection:Upgrade&#8217;<\/i> and <i>&#8216;Upgrade:websocket&#8217;<\/i> and what requests the server to change this connection to a socket one. The <i>Sec-WebSocket-Key<\/i> header is what client sends to the server. The server crafts another key with this and returns it back in the response header. A response header looks like this.\n<\/p>\n<pre>\nHTTP\/1.1 101 Switching Protocols\nConnection:Upgrade\nSec-Websocket-Accept:7CAJHdL7QMG4ceqd0M1O8SDbM2Q=\nSec-Websocket-Extensions:permessage-deflate\nUpgrade:websocket\nVia:1.1 vegur\n<\/pre>\n<p>\n\tOn receiving the <i>Sec-Websocket-Accept<\/i> header, the handshake is completed, and now the client and server are connected via persistent sockets, ready to perform both way message delivery.\n<\/p>\n<p>\n\tClick &#8216;Connect&#8217; button to initiate WebSocket handshake. The server will respond with a timestamp every 2500 milliseconds. Also, the server will echo back everything to send at it. The close button will call the WebSocket.close() method which will terminate the connection.<\/p>\n<h4>Message Box<\/h4>\n<div id=\"list\" style=\"height:100px;overflow-y:scroll;border:1px solid\">\n<ul id=\"msglist\">\n<\/ul><\/div>\n<p>    <center><br \/>\n\t    <button id=\"connect\">Connect<\/button><br \/>\n\t    <input type=\"text\" id=\"inp\" \/><br \/>\n\t\t<button id=\"send\">Send<\/button><br \/>\n\t\t<button id=\"close\">Close<\/button><br \/>\n\t<\/center>\n<\/p>\n<p>\n\tPretty interesting, isn&#8217;t it. Things get even more interesting when you use a readymade library built on top of WebSockets, such as <a href=\"https:\/\/socket.io\">Socket.io<\/a>. It supports all browsers (through fallback to XHR\/polling), has better looking APIs, is easy to use and allows you to broadcast without having to worry much about raw connections. If you&#8217;re going to use these WebSockets in production, there&#8217;s no reason not to use Socket.io. Using native websockets is not recommended if you&#8217;re planning to support some legacy browsers. Even Mozilla terms it as an &#8216;experimental technology&#8217;. Check out the <a href=\"https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/WebSocket#Browser_compatibility\">compatibility table<\/a> for more information.\n<\/p>\n<p>\n\tI hope this post was informative. I did learn a lot while researching on this topic, and I&#8217;m glad I did. As always, thank you for reading. Please drop a comment in case of feedback or correction.\n<\/p>\n<p><script src=\"https:\/\/cdnjs.cloudflare.com\/ajax\/libs\/jquery\/3.0.0-beta1\/jquery.min.js\"><\/script><br \/>\n<script type=\"text\/javascript\">\n\tfunction hasSocket() {\n\t\tif(window.WebSocket) {\n\t\t\tdocument.getElementById('hasBtn').innerHTML = 'Supported';\n\t\t\tdocument.getElementById('hasBtn').disabled = true;\n\t\t} else {\n\t\t\tdocument.getElementById('hasBtn').innerHTML = 'Not supported';\n\t\t\tdocument.getElementById('hasBtn').disabled = true;\n\t\t}\n\t}\n\tvar ws;\n\t$('#connect').click(function() {\n\t\tws = new WebSocket('wss:\/\/nagekar-ws.herokuapp.com\/');\n\t\tws.onmessage = function(msg) {\n\t\t\t$('#msglist').append('<\/p>\n<li style=\"color: green\">' + msg.data + '<\/li>\n<p>').focus();\n\t\t\t$('#list').scrollTop($('ul li').last().position().top + $('ul li').last().height());\n\t\t};\n\t});\n\t$('#send').click(function() {\n\t\tvar msg = $('#inp').val();\n\t\t$('#msglist').append('<\/p>\n<li style=\"color: blue\">Message to server: ' + msg + '<\/li>\n<p>').focus();\n\t\t$('#list').scrollTop($('ul li').last().position().top + $('ul li').last().height());\n\t\tws.send(msg);\n\t});\n\t$('#close').click(function() {\n\t\tws.close();\n\t\t$('#msglist').append('<\/p>\n<li style=\"color: red\">' + 'Connection Closed' + '<\/li>\n<p>').focus();\n\t\t$('#list').scrollTop($('ul li').last().position().top + $('ul li').last().height());\n\t})\n<\/script><\/p>\n","protected":false},"excerpt":{"rendered":"<p>If you&#8217;re like me, then you must have gone nuts on hearing about WebSockets for the first time. We now have a totally independent protocol that will not terminate connection after a request-response cycle, which means all hacks to keep a persistent connection from the browser (long polling, I&#8217;m looking at you) would now be [&hellip;]<\/p>\n","protected":false},"author":2,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[],"tags":[14],"class_list":["post-1121","post","type-post","status-publish","format-standard","hentry","tag-javascript"],"_links":{"self":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/posts\/1121","targetHints":{"allow":["GET"]}}],"collection":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/comments?post=1121"}],"version-history":[{"count":0,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/posts\/1121\/revisions"}],"wp:attachment":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/media?parent=1121"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/categories?post=1121"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/tags?post=1121"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}