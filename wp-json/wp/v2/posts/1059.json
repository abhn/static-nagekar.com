{"id":1059,"date":"2018-11-19T23:00:00","date_gmt":"2018-11-19T23:00:00","guid":{"rendered":"http:\/\/wp.nagekar.com\/2018\/11\/19\/lets-talk-about-css\/"},"modified":"2018-11-19T23:00:00","modified_gmt":"2018-11-19T23:00:00","slug":"lets-talk-about-css","status":"publish","type":"post","link":"https:\/\/nagekar.com\/2018\/11\/lets-talk-about-css.html","title":{"rendered":"Let&#8217;s Talk About CSS"},"content":{"rendered":"<p>\n    CSS can be deceptively complex. And to most programmers, rightly so. We programmers tend to find patterns that help us relate the new information to what already exists within us, draw parallels and think of real world analogies. That is one reason learning your second or third programming language is much faster than learning the first if they share some paradigms. But with CSS, many of us have a memorize-first approach. While it works, it is more fun (and easier to debug) if we understands a little bit of the under-the-hood stuff.\n<\/p>\n<p>\n    In this post, let&#8217;s try to demystify some of the aspects of CSS that we as engineers should&#8217;ve asked when we got started with CSS. Better late than never, right?\n<\/p>\n<h3>Understanding The Browser<\/h3>\n<p>\n    Starting with something basic: When you request a webpage, and it is downloaded to your system (computer, mobile phone etc), it is in the form of HTML code (at the application layer, that is). The browser then parses the html, line by line, downloading any external resources that it finds with separate HTTP requests. The HTML that is parsed is structured as a <a href=\"https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/Document_Object_Model\/Introduction\">DOM<\/a> tree, which can be thought of like a family tree, but with HTML elements. DOM defines the structure of the page; what goes where and what information does each node have.\n<\/p>\n<p>\n    On the side, the browser (in that, the rendering engine) is also processing the CSS files. CSS files are processed, and then styles for each node (HTML element, that is) is calculated, and applied to that node. The end result is &#8216;painted&#8217; and rendered to the client&#8217;s screen.\n<\/p>\n<p>\n    So as you can tell, it is pretty straightforward. What&#8217;s interesting is the process of calculating the styles to be applied to each node, and that&#8217;s what we&#8217;ll be talking about for the rest of this article.\n<\/p>\n<h3>CSS Parsing<\/h3>\n<p>\n    There are a couple of challenges when deciding what style applies to a particular element. <\/p>\n<ul>\n<li>The engine has to first parse the CSS and get all the values for each property.<\/li>\n<li>Then the engine has to decide what set of properties get applied to each element depending upon the specificity of the selectors, inherited and default values (since each element may have multiple rules that seem to style it).<\/li>\n<li>Then the selected styles are converted into pixel values (we may have used rems, ems, percentages or vh\/vw in our CSS code) as that&#8217;s what browsers understand.<\/li>\n<\/ul>\n<p>\n    In particular, the CSS engine looks for the following when dealing with a style and deciding if it really applies to a given node.\n<\/p>\n<h4>!important<\/h4>\n<p>\n    If a property has <code>!important<\/code> in the value, it is immediately selected for the final processing irrespective of the specificity and code order.\n<\/p>\n<h4>Specificity<\/h4>\n<p>\n    To put it simply, specificity deals with how &#8216;specific&#8217; is the selector (based on concrete rules). For example, if you have some list-items, each with a class selector and CSS <code>background-color: red;<\/code> and one of them also has an ID selector with the CSS <code>background-color: green;<\/code>, then which background-color do you think gets applied to that particular list-item? It is the style in the ID selector.\n<\/p>\n<p>\n    Similarly, if the ID selected list-item had an inline style, the inline style would take precedence. Formally the hierarchy is\n<\/p>\n<pre>Inline style > ID selector > Class selector > Element selector<\/pre>\n<p>\n    Browsers maintain an internal tuple of the form (0,0,0,0) representing the counts of each selector hierarchy viz. (inline-style, ID, class, element). For the selector <code>h1.heading#top-heading<\/code>, the tuple will look like (0,1,1,1), that is, one for ID, one for class and the last for element selector.\n<\/p>\n<p>\n    Suppose you had another selector <code>h1.heading#top-heading#blue-color<\/code>. Now the tuple for this would look like (0,2,1,1) as there are two ID selectors. If the browser had to choose between the former and this, it would choose this one as it has a higher specificity.\n<\/p>\n<h4>Source Order<\/h4>\n<p>\n    Now what happens if specificity of two selectors match? Simple, the last selector in the source code (even in case of multiple files) gets selected for application.\n<\/p>\n<h4>Cascade<\/h4>\n<blockquote><p>\n    Cascade (n): A process whereby something, typically information or knowledge, is successively passed on.\n<\/p><\/blockquote>\n<p>\n    The term Cascading in <i>Cascading Style Sheets<\/i> says something about the priority scheme that&#8217;s used to determine what style gets applied to an element when multiple rules match. In simpler words, if body has <code>font-family: Arial;<\/code> specified and the h1 has <code>font-family: Helvetica;<\/code>, Helvetica gets applied to the h1. However, if font-family on h1 wasn&#8217;t explicitly declared, Arial would&#8217;ve been selected by inheritance. <b>This is how inheritance works in CSS.<\/b>\n<\/p>\n<p>\n    Not every property is inherited. And it doesn&#8217;t make a lot of sense to inherit everything either. For example, setting <code>margin: 0 10px;<\/code> on body doesn&#8217;t automatically apply it to every child of body which doesn&#8217;t have an explicitly declared margin property. The ones which don&#8217;t have an explicitly declared margin get a default margin of 0px. <b>This is how default properties work in CSS.<\/b>\n<\/p>\n<p>\n    The obvious followup question is, how to tell if something will be inherited or default value will be selected? Honestly, I&#8217;m not sure. I usually just ask myself if it makes sense to have this property inherited or defaulted. More often than not, that&#8217;s enough. In case you&#8217;d want to explicitly make a property to inherit or default a value, use <code>inherit<\/code> and <code>initial<\/code> keyword respectively.\n<\/p>\n<h3>In Closing<\/h3>\n<p>\n    That&#8217;s it for this little primer. I hope you found it useful. For a nice illustrated guide on this, check out <a href=\"https:\/\/hacks.mozilla.org\/2017\/08\/inside-a-super-fast-css-engine-quantum-css-aka-stylo\/\">this article on Mozilla<\/a>. Thank you for reading.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>CSS can be deceptively complex. And to most programmers, rightly so. We programmers tend to find patterns that help us relate the new information to what already exists within us, draw parallels and think of real world analogies. That is one reason learning your second or third programming language is much faster than learning the [&hellip;]<\/p>\n","protected":false},"author":2,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[],"tags":[20,29],"class_list":["post-1059","post","type-post","status-publish","format-standard","hentry","tag-css","tag-web"],"_links":{"self":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/posts\/1059","targetHints":{"allow":["GET"]}}],"collection":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/comments?post=1059"}],"version-history":[{"count":0,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/posts\/1059\/revisions"}],"wp:attachment":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/media?parent=1059"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/categories?post=1059"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/tags?post=1059"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}