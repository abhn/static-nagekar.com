{"id":1125,"date":"2016-02-10T23:00:00","date_gmt":"2016-02-10T23:00:00","guid":{"rendered":"http:\/\/wp.nagekar.com\/2016\/02\/10\/callbacks-eventloop-in-javascript-explained\/"},"modified":"2016-02-10T23:00:00","modified_gmt":"2016-02-10T23:00:00","slug":"callbacks-eventloop-in-javascript-explained","status":"publish","type":"post","link":"https:\/\/nagekar.com\/2016\/02\/callbacks-eventloop-in-javascript-explained.html","title":{"rendered":"Callbacks And Event Loop Explained"},"content":{"rendered":"<p>\n\tCallbacks are the things that make writing Javascript fun. If you think you are better off writing Javascript the way you wrote C and Java, then you are not really feeling the essence of this beautiful language. I found it rather hard to get used to this style of programming, called affectionately as the non-blocking style. What is this difficult sounding technique, and how can you make use of it to write better code is what we&#8217;re going to see in this little essay.\n<\/p>\n<p>\n\tStarting with the most basic explanation of what a callback is. Suppose I have two functions A and B. Although I can execute both of them myself, what I can do is execute A and ask A to execute B for me. Yes, that is all there is to the callbacks thing. I have two functions, I execute one and then ask it to execute the other one for me. Simple.\n<\/p>\n<p>\n\tBut, you might ask, why I would ever want to do such a thing. Well, think about it this way. Computer processing is way, way faster than any I\/O in question, especially when the I\/O is on the other side of the network (or globe, for that matter) which is usual in the case of most web applications. Now, if you write code such that it queries a remote (or local) database and uses those results to carry on further processing, it results in a bottleneck. The processor executes instructions in the order of nanoseconds. An I\/O request to the disk or network takes a few milliseconds at best, or a million times more time than what a processor needs to do a single atomic task. So essentially writing code that waits for results from I\/O is simply wastage of the precious CPU cycles that could&#8217;ve been put to better use in the meantime.\n<\/p>\n<p>\n\tA callback is also of great use when you want to make a function, say A, do things according to the context by supplying a specialized function B at the runtime. For example,\n<\/p>\n<p><script src=\"https:\/\/gist.github.com\/abhn\/22fa7b521b4013c30bdd.js\"><\/script><\/p>\n<p>\n\tSo let&#8217;s get into some (pseudo) code. We will first see what it is like to write code without callbacks and blocking IO and then examine some issues. Then we will write the same code using callbacks and non-blocking IO and see if we have rectified (or at least mitigated) those issues.\n<\/p>\n<p><script src=\"https:\/\/gist.github.com\/abhn\/6b032655b0924b0ed301.js\"><\/script><\/p>\n<p>\n\tNow this code is blocked when the Javascript engine is waiting for the Mongodb query to execute and return. It may take a few milliseconds, and only after that does the control of the program moves to the next lines. If the database hangs up for any reason, then the response will never reach the end user, regardless of whether the login credentials were correct or not (or let the user know something went wrong). It may also happen that the Javascript engine continues the execution with &#8216;undefined&#8217; returned, resulting in falsy block being executed each time. Having addressed these problems, let us now write the asynchronous version of the same (pseudo) code.\n<\/p>\n<p><script src=\"https:\/\/gist.github.com\/abhn\/c1f4527a33f92a304d7e.js\"><\/script><\/p>\n<p>\n\tThe callback function in a way keeps waiting for the response from the database in the background white the flow of program is not interrupted. As soon as the reply comes, the code in the callback function is executed. That sounds neat. Wait a second. Didn&#8217;t we all learn that Javascript is single threaded and does a single job at a time and what not? Then how is the callback supposed to listen when the browser is already executing the code below it?\n<\/p>\n<p>\n\tTo understand that, you&#8217;ll have to stop believing every thing you write in Javascript is Javascript. Yes, I mean it. Javascript is single threaded, but there is much more to Javascript than just a single <b>call stack<\/b>. Ok first, what is a call stack. Whenever a javascript file is executed, the engine creates a context for the code to run. This is the global execution context. It sits at the bottom of the call stack. Whenever a new function is invoked (or &#8216;called&#8217;), a new execution context is pushed on top of the stack. After the execution completes, the execution context is popped off the stack. After the last line of code is interpreted, the global context is popped off the stack.\n<\/p>\n<p>\n\tWell and good. But what about that setTimeout function that you set for the next 10 seconds? And our own mongodb query. Where did those go? The setTimeout is actually a webAPI provided to us, the Javascript developers, by the browser. Similarly, our mongodb query command was not a Javascript thingy, but a C++ API from the Nodejs bag of goodies. These events are handled by their respective environment, and when they finish execution, they enter what is called the <b>callback queue<\/b>. There, they wait until the call stack is completely empty. Once the call stack in empty (all Javascript code is done running), the <b>event loop<\/b> kicks in, pushes the callback functions waiting in the call back queue on top of the stack, one by one. A great way to visualize what the above paragraph just said is to try it out yourself at <a href=\"https:\/\/latentflip.com\/loupe\" target=\"_blank\" rel=\"noopener\">loupe by Philip Roberts<\/a>. He&#8217;s an amazing guy and you should totally check out his talks.\n<\/p>\n<p>\n\tSo that was it for this little article. Hope to have helped you. Keep digging.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Callbacks are the things that make writing Javascript fun. If you think you are better off writing Javascript the way you wrote C and Java, then you are not really feeling the essence of this beautiful language. I found it rather hard to get used to this style of programming, called affectionately as the non-blocking [&hellip;]<\/p>\n","protected":false},"author":2,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[],"tags":[14],"class_list":["post-1125","post","type-post","status-publish","format-standard","hentry","tag-javascript"],"_links":{"self":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/posts\/1125","targetHints":{"allow":["GET"]}}],"collection":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/comments?post=1125"}],"version-history":[{"count":0,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/posts\/1125\/revisions"}],"wp:attachment":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/media?parent=1125"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/categories?post=1125"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/tags?post=1125"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}