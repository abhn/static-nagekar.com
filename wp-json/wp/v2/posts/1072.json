{"id":1072,"date":"2018-07-05T22:00:00","date_gmt":"2018-07-05T22:00:00","guid":{"rendered":"http:\/\/wp.nagekar.com\/2018\/07\/05\/eli5-key-derivation\/"},"modified":"2018-07-05T22:00:00","modified_gmt":"2018-07-05T22:00:00","slug":"eli5-key-derivation","status":"publish","type":"post","link":"https:\/\/nagekar.com\/2018\/07\/eli5-key-derivation.html","title":{"rendered":"ELI5 &#8211; Key Derivation Function"},"content":{"rendered":"<p>\n\tWe&#8217;ve heard that AES and other block ciphers require specific key sizes; 128, 256 and 512 bits. But I don&#8217;t ever remember having to calculate my password length based on the underlying key size. Never have I read on a website <i>&#8220;passwords need to be of 16 ASCII characters, 1 byte each, to make a total of 128 bits of key material&#8221;<\/i>. So what lies between me entering an arbitrarily sized password and the encryption algorithm receiving a 128\/256 bit nicely sized key. Let&#8217;s find that out in this ELI5.\n<\/p>\n<h3>Key Derivation Function<\/h3>\n<p>\n\tA Key Derivation Function (wait for it&#8230;) derives cryptographic key(s) from a password. Generally speaking, the passwords we humans come up with are something like &#8220;MyAwesomeDog007&#8221; which, while long and easy to remember, just don&#8217;t have enough entropy for cryptographic applications. On the other hand, a key derived from a simple password &#8220;ml6xU*dwGS5rvE!dcIg6509w$$&#8221; (that&#8217;s not a real key, a real key would in most cases be binary) is complex and entropy rich. This is the first purpose a KDF serves; to increase the entropy of a password and making it suitable for use in other algorithms such as AES.\n<\/p>\n<p>\n\tThe second purpose that KDFs serve is that they make brute forcing infeasible. Due to the high computational costs of running a good KDF, brute forcing is typically not achievable for any half decent password. Of course, it won&#8217;t protect a user from a dictionary attack if she selects a password such as &#8220;password123&#8221;.\n<\/p>\n<h3>Working<\/h3>\n<p>\n\tA KDF takes an arbitrarily sized input that has low entropy (user-supplied password, for example), runs some hash-based algorithms on it, and output a random looking fixed sized cryptographic key (which becomes input key to encryption and <a href=\"\/2018\/07\/eli5-message-authentication-code.html\">MACing<\/a> algorithms later). A KDF can be thought of as a pseudo-random function (PRF) which maps an input password to an output key. As a PRF, the input and output mappings should look completely random to an attacker and in no circumstance should he be able to get the original password from a cryptographic key (that is, the function should be one way). The high iteration count makes computing KDF an expensive affair. This is acceptable for a legitimate user but will prevent <a href=\"https:\/\/en.wikipedia.org\/wiki\/Brute_force_attack\">brute forcing of the password<\/a>.\n<\/p>\n<p>\n\tTypically, key derivation functions employ keyed hash algorithms or HMAC. <a href=\"https:\/\/en.wikipedia.org\/wiki\/Salt_(cryptography)\">Cryptographic salt<\/a> is used to prevent <a href=\"https:\/\/en.wikipedia.org\/wiki\/Rainbow_table\">rainbow table attacks<\/a> (precomputed hash lookups). The number of iterations (in the order of tens to hundreds of thousands) of the hash function is selected to slow down bruteforce attacks.\n<\/p>\n<h3>Implementations<\/h3>\n<p>\n\tA simple key derivation function is <b><a href=\"https:\/\/en.wikipedia.org\/wiki\/PBKDF2\">Password Based Key Derivation Function 2, PBKDF2<\/a><\/b>. It takes as input a pseudo-random function (such a SHA-256), user supplied key, salt (64+ bits), number of iterations, length of output key, and outputs a key of specified length.\n<\/p>\n<p>\n\tAlthough PBKDF2 is still used and recommended, modern alternatives such as <a href=\"https:\/\/en.wikipedia.org\/wiki\/Scrypt\">Scrypt<\/a> and <a href=\"https:\/\/en.wikipedia.org\/wiki\/Argon2\">Argon2<\/a> offer much better resistance to bruteforce.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>We&#8217;ve heard that AES and other block ciphers require specific key sizes; 128, 256 and 512 bits. But I don&#8217;t ever remember having to calculate my password length based on the underlying key size. Never have I read on a website &#8220;passwords need to be of 16 ASCII characters, 1 byte each, to make a [&hellip;]<\/p>\n","protected":false},"author":2,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[],"tags":[7,6],"class_list":["post-1072","post","type-post","status-publish","format-standard","hentry","tag-cryptography","tag-eli5"],"_links":{"self":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/posts\/1072","targetHints":{"allow":["GET"]}}],"collection":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/comments?post=1072"}],"version-history":[{"count":0,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/posts\/1072\/revisions"}],"wp:attachment":[{"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/media?parent=1072"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/categories?post=1072"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/nagekar.com\/wp-json\/wp\/v2\/tags?post=1072"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}